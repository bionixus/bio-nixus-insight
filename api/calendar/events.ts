import { createClient } from '@sanity/client'

const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'BioNixus2026!'

const sanityServer = createClient({
  projectId: process.env.VITE_SANITY_PROJECT_ID || 'h2whvvpo',
  dataset: process.env.VITE_SANITY_DATASET || 'production',
  useCdn: false,
  apiVersion: '2024-01-01',
  token: process.env.SANITY_API_TOKEN?.trim(),
})

async function handler(req: any, res: any) {
  // ─── POST: Create a new calendar event ───
  if (req.method === 'POST') {
    try {
      const { title, type, scheduledDate, status, priority, description, tags, targetAudience, recurringEvent } = req.body

      if (!title || !type || !scheduledDate) {
        return res.status(400).json({ error: 'title, type, and scheduledDate are required' })
      }

      const doc: any = {
        _type: 'contentCalendar',
        title,
        type,
        scheduledDate,
        status: status || 'idea',
        priority: priority || 'medium',
      }

      if (description) doc.description = description
      if (tags && tags.length > 0) doc.tags = tags
      if (targetAudience && targetAudience.length > 0) doc.targetAudience = targetAudience
      if (recurringEvent) doc.recurringEvent = recurringEvent

      const created = await sanityServer.create(doc)
      return res.status(201).json({ success: true, event: created })
    } catch (error: any) {
      console.error('Calendar create error:', error)
      return res.status(500).json({ error: error.message })
    }
  }

  // ─── PATCH: Update an existing calendar event ───
  if (req.method === 'PATCH') {
    try {
      const { eventId, ...updates } = req.body

      if (!eventId) {
        return res.status(400).json({ error: 'eventId is required' })
      }

      // If marking as published, auto-set publishedAt
      if (updates.status === 'published' && !updates.publishedAt) {
        updates.publishedAt = new Date().toISOString()
      }

      const updated = await sanityServer.patch(eventId).set(updates).commit()
      return res.status(200).json({ success: true, event: updated })
    } catch (error: any) {
      console.error('Calendar update error:', error)
      return res.status(500).json({ error: error.message })
    }
  }

  // ─── DELETE: Remove a calendar event ───
  if (req.method === 'DELETE') {
    try {
      const eventId = req.body?.eventId || req.query?.eventId
      if (!eventId) {
        return res.status(400).json({ error: 'eventId is required' })
      }
      await sanityServer.delete(eventId)
      return res.status(200).json({ success: true, deleted: eventId })
    } catch (error: any) {
      console.error('Calendar delete error:', error)
      return res.status(500).json({ error: error.message })
    }
  }

  // ─── GET: Fetch calendar events ───
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  try {
    const { start, end, type } = req.query

    // Build query
    let conditions = ['_type == "contentCalendar"']

    if (start) {
      conditions.push(`scheduledDate >= "${start}"`)
    }

    if (end) {
      conditions.push(`scheduledDate <= "${end}"`)
    }

    if (type && type !== 'all') {
      conditions.push(`type == "${type}"`)
    }

    const whereClause = conditions.join(' && ')

    // Fetch calendar events
    const calendarEvents = await sanityServer.fetch(`
      *[${whereClause}] | order(scheduledDate asc) {
        _id,
        title,
        type,
        scheduledDate,
        status,
        description,
        priority,
        tags,
        targetAudience,
        publishedAt,
        linkedContent,
        author->{
          name,
          _id
        },
        recurringEvent
      }
    `)

    // Fetch published newsletters
    const newsletters = await sanityServer.fetch(`
      *[_type == "newsletter" && defined(scheduledFor)] {
        _id,
        title,
        scheduledFor,
        sentAt,
        status,
        targetSegments,
        stats
      }
    `)

    // Fetch published blog posts
    const posts = await sanityServer.fetch(`
      *[_type == "post" && defined(publishedAt)] {
        _id,
        title,
        publishedAt,
        category,
        country,
        author->{
          name
        }
      }
    `)

    // Convert newsletters to calendar events
    const newsletterEvents = newsletters.map((n: any) => ({
      _id: `newsletter-${n._id}`,
      sourceId: n._id,
      title: n.title || 'Untitled Newsletter',
      type: 'newsletter',
      scheduledDate: n.scheduledFor,
      status: n.status === 'sent' ? 'published' : n.status,
      publishedAt: n.sentAt,
      targetAudience: n.targetSegments,
      stats: n.stats,
      isAutoGenerated: true
    }))

    // Convert blog posts to calendar events
    const postEvents = posts.map((p: any) => ({
      _id: `post-${p._id}`,
      sourceId: p._id,
      title: p.title || 'Untitled Post',
      type: 'blog',
      scheduledDate: p.publishedAt,
      status: 'published',
      publishedAt: p.publishedAt,
      author: p.author,
      category: p.category,
      country: p.country,
      isAutoGenerated: true
    }))

    // Combine all events
    const allEvents = [
      ...calendarEvents,
      ...newsletterEvents,
      ...postEvents
    ].sort((a: any, b: any) =>
      new Date(a.scheduledDate).getTime() - new Date(b.scheduledDate).getTime()
    )

    return res.status(200).json({
      events: allEvents,
      stats: {
        total: allEvents.length,
        byType: {
          newsletter: allEvents.filter((e: any) => e.type === 'newsletter').length,
          blog: allEvents.filter((e: any) => e.type === 'blog').length,
          social: allEvents.filter((e: any) => e.type === 'social').length,
          report: allEvents.filter((e: any) => e.type === 'report').length,
          campaign: allEvents.filter((e: any) => e.type === 'campaign').length,
          announcement: allEvents.filter((e: any) => e.type === 'announcement').length
        },
        byStatus: {
          idea: allEvents.filter((e: any) => e.status === 'idea').length,
          draft: allEvents.filter((e: any) => e.status === 'draft').length,
          scheduled: allEvents.filter((e: any) => e.status === 'scheduled').length,
          published: allEvents.filter((e: any) => e.status === 'published').length
        }
      }
    })
  } catch (error: any) {
    console.error('Calendar fetch error:', error)
    return res.status(500).json({ error: error.message })
  }
}

export default function authHandler(req: any, res: any) {
  const authHeader = req.headers.authorization
  if (!authHeader || !authHeader.startsWith('Bearer ') || authHeader.substring(7) !== ADMIN_PASSWORD) {
    return res.status(401).json({ error: 'Unauthorized' })
  }
  return handler(req, res)
}
